"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[283],{3344:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"Devices/touch","title":"Touch","description":"Touch support guide","source":"@site/docs/Devices/touch.md","sourceDirName":"Devices","slug":"/Devices/touch","permalink":"/Axis/docs/Devices/touch","draft":false,"unlisted":false,"editUrl":"https://github.com/NeonD00m/axis/edit/main/docs/Devices/touch.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Touch","description":"Touch support guide","sidebar_position":3},"sidebar":"defaultSidebar","previous":{"title":"Controller","permalink":"/Axis/docs/Devices/controller"}}');var i=t(4848),s=t(8453);const r={title:"Touch",description:"Touch support guide",sidebar_position:3},a="Touch",u={},c=[{value:"Hold",id:"hold",level:3},{value:"Move",id:"move",level:3}];function l(e){const n={admonition:"admonition",code:"code",h1:"h1",h3:"h3",header:"header",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"touch",children:"Touch"})}),"\n",(0,i.jsxs)(n.p,{children:["Touch controls can often be one of the most difficult parts to implement well, since you need to consider much more factors in how players will interact with your game. Axis tries to give you a lot of power to adjust inputs however you want through ",(0,i.jsx)(n.code,{children:"hold()"})," and ",(0,i.jsx)(n.code,{children:"move()"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"hold",children:"Hold"}),"\n",(0,i.jsx)(n.p,{children:"Holding is the easiest method of using UI touch controls with Axis. When you write your keymap, you won't be able to use any sort of special keys for mobile in most cases, so you implement it as usual for other devices."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"local aim = Axis.input {\r\n    Enum.UserInputType.MouseButton2,\r\n    Enum.KeyCode.ButtonL2\r\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"In this example, we're going to be writing support for aiming down sights (ADS) in an FPS game. Imagine we have the following ADS system to handle the visuals:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"local function aimDownSights()\r\n    aim:update()\r\n\r\n    local isAiming: number = if aim:pressed() then 1 else 0\r\n    local gunOffset = hipOffset:Lerp(aimOffset, isAiming)\r\n    ...\r\nend\n"})}),"\n",(0,i.jsxs)(n.p,{children:["After designing a UI button (",(0,i.jsx)(n.code,{children:"aimButton"}),") for mobile players, we can use ",(0,i.jsx)(n.code,{children:"hold()"})," to add the input value to the axis:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"local release, touch = nil, nil\r\n\r\naimButton.InputBegan:Connect(function(input)\r\n    if input.UserInputType ~= Enum.UserInputType.MouseButton1 and\r\n        input.UserInputType ~= Enum.UserInputType.Touch then\r\n        return\r\n    end\r\n    if input.UserInputState ~= Enum.UserInputState.Begin then\r\n        return\r\n    end\r\n    touch = input\r\n    release = aim:hold() -- this sets the value of the aim input to 1, as if there was a right click\r\nend)\r\n\r\nUserInputService.InputEnded:Connect(function(input)\r\n    if not releaseJump or input ~= touch or input.UserInputState ~= Enum.UserInputState.End then\r\n        return\r\n    end\r\n    if input.UserInputType ~= Enum.UserInputType.MouseButton1 and\r\n        input.UserInputType ~= Enum.UserInputType.Touch then\r\n        return\r\n    end\r\n    release() -- this releases the hold, as if the right click was released\r\n    release = nil\r\nend)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This code would make sure that your game can properly support mobile players with intuitive controls, while keeping input handling outside of your game logic (in this case, the ",(0,i.jsx)(n.code,{children:"aimDownSights()"})," function)."]}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["You may be wondering why we're using this complicated method instead of ",(0,i.jsx)(n.code,{children:"aimButton.Activated"}),". Well this strategy is to allow mobile players to continue to drag their camera around while pressing the button (and holding the input axis). This is ideal in a scenario where the gun might shoot automatically when aiming over a player on a mobile device. But this is more common with 'shoot' buttons."]})}),"\n",(0,i.jsx)(n.h3,{id:"move",children:"Move"}),"\n",(0,i.jsxs)(n.p,{children:["If you are using a UI framework like Roact or Vide, or maybe you just have state in a different library, you may want to have a system run every frame that uses ",(0,i.jsx)(n.code,{children:"move()"})," to connect that state to an input axis."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"local isShootButtonPressed -- state that comes from somewhere else\r\nlocal shoot = Axis.input {\r\n    Enum.KeyCode.ButtonR2,\r\n    Enum.KeyCode.MouseButton1\r\n}\r\nlocal function handleInput()\r\n    if isShootButtonPressed() then\r\n        shoot:move(1)\r\n    end\r\n    -- maybe do the same for other input axes\r\nend\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"move()"})," works just like a hold(), except that it is optimized to only add that value to the axis for a single update. This works in this situation since you can only check whether the button is pressed every frame, so it makes sense to just move the axis for that frame and then have it reset automatically the next frame."]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var o=t(6540);const i={},s=o.createContext(i);function r(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);