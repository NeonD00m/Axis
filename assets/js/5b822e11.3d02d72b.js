"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[521],{4964:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"Introduction/getting_started","title":"Getting Started","description":"How to get started with Axis","source":"@site/docs/Introduction/getting_started.md","sourceDirName":"Introduction","slug":"/Introduction/getting_started","permalink":"/Axis/docs/Introduction/getting_started","draft":false,"unlisted":false,"editUrl":"https://github.com/NeonD00m/axis/edit/main/docs/Introduction/getting_started.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Getting Started","description":"How to get started with Axis","sidebar_position":1},"sidebar":"defaultSidebar","previous":{"title":"Glossary","permalink":"/Axis/docs/intro"},"next":{"title":"Best Practices","permalink":"/Axis/docs/Introduction/best_practices"}}');var i=t(4848),r=t(8453);const a={title:"Getting Started",description:"How to get started with Axis",sidebar_position:1},o="Getting Started",l={},c=[{value:"Installation",id:"installation",level:2},{value:"Usage",id:"usage",level:2},{value:"Input Axes",id:"input-axes",level:3},{value:"Axis Weights",id:"axis-weights",level:3},{value:"Vector Axes",id:"vector-axes",level:3},{value:"More Information",id:"more-information",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"getting-started",children:"Getting Started"})}),"\n",(0,i.jsx)(n.h2,{id:"installation",children:"Installation"}),"\n",(0,i.jsxs)(n.p,{children:["Currently only available on ",(0,i.jsx)(n.a,{href:"https://pesde.dev/packages/killergg/axis",children:"pesde"})]}),"\n",(0,i.jsx)(n.h2,{id:"usage",children:"Usage"}),"\n",(0,i.jsx)(n.p,{children:"While this library is agnostic and doesn't require an ECS of any sort, it is definitely ECS-oriented since its meant to be run in systems. Input axes run on a frame by frame basis, meaning they need to be updated every frame."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'while wait() do\r\n    attack:update() -- update the input axes\r\n    if attack:pressed() then -- fires once, when the input is newly pressed\r\n        print("Attacked!")\r\n    end\r\nend\n'})}),"\n",(0,i.jsx)(n.h3,{id:"input-axes",children:"Input Axes"}),"\n",(0,i.jsx)(n.p,{children:"To create an input axis, you need to define a keymap. These keymaps can contain keybinds for any devices, as shown here:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"local attack = Axis.input {\r\n    Enum.KeyCode.E, -- for keyboard, though usually redundant with mouse\r\n    Enum.UserInputType.MouseButton1, -- for mouse\r\n    Enum.KeyCode.ButtonR2, -- for xbox/ps4 controllers\r\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"In this example, three axes have been defined in the input, E, left click, and the right trigger on console. These axes for example are all positive (by default), meaning that each can either be equal to 0 or 1."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"-- if any of the above axes are equal to 1, the input is considered pressing\r\nif attack:pressing() then\r\n...\n"})}),"\n",(0,i.jsxs)(n.p,{children:["But lets use this idea of axes to use the mouse's scroll wheel as input. The scroll wheel is a ",(0,i.jsx)(n.em,{children:"special key"})," where the value can either be 0 (for no scroll), 1 (for scrolling up), or -1 (for scrolling down). This means that the axis could be negative or positive."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"local zoom = Axis.input { Enum.UserInputType.MouseWheel }\n"})}),"\n",(0,i.jsx)(n.p,{children:'In this case, pressing == when the user is scrolling in either direction. (Pressing is true when the whole input is not equal to 0, this is called being "activated" in the API).'}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"local pressing = zoom:pressing()\n"})}),"\n",(0,i.jsxs)(n.p,{children:["So now, using ",(0,i.jsx)(n.code,{children:"read()"})," is more useful, since it returns the current and previous values of the axis."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"local current, previous = zoom:read()\r\n-- current will equal either, -1, 0, or 1\r\n-- same for previous!\n"})}),"\n",(0,i.jsx)(n.h3,{id:"axis-weights",children:"Axis Weights"}),"\n",(0,i.jsx)(n.p,{children:"By default input axes are given a weight of 1. This means that if one axis was positive and another was negative, they would cancel each other out."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"local movementIn2D = Axis.input {\r\n    [Enum.KeyCode.A] = -1,\r\n    Enum.KeyCode.D, -- by default, given a weight of positive 1\r\n    -- [Enum.KeyCode.D] = 1, -- this is explicit, but has same behavior\r\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"If both keys were being pressed at the same time, the value of the input as a whole would be 0, since 1 + (-1) = 0. This is how input is calculated internally- it's just a sum of all the axes. You could weight axes very differently, if you wanted:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"local acceleratePedal = Axis.input {\r\n    [Enum.KeyCode.Q] = 3,\r\n    [Enum.KeyCode.W] = 1,\r\n}\r\nlocal pedal = acceleratePedal:read()\r\n-- pedal will equal either 4, 3, 1, or 0\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"warning",children:(0,i.jsxs)(n.p,{children:["Beware of using variable magnitude weights when reading with ",(0,i.jsx)(n.code,{children:"read()"})," as you may get unexpected results. Remember that the result of ",(0,i.jsx)(n.code,{children:"read()"})," is a sum of all the axes, so the value have a magnitude of more than 1 or less than -1."]})}),"\n",(0,i.jsx)(n.h3,{id:"vector-axes",children:"Vector Axes"}),"\n",(0,i.jsx)(n.p,{children:"The cool thing about modelling input as axes is that they can be vectors. For example, the common usecase of character movement with WASD:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"local move = Axis.input {\r\n    [Enum.KeyCode.W] = Vector2.new(0, 1),\r\n    [Enum.KeyCode.S] = Vector2.new(0, -1),\r\n    [Enum.KeyCode.A] = Vector2.new(-1, 0),\r\n    [Enum.KeyCode.D] = Vector2.new(1, 0),\r\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"But then you can also add support for the thumbsticks:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"...\r\n    [Enum.KeyCode.D] = Vector2.new(1, 0),\r\n    Enum.KeyCode.Thumbstick1, -- could be any Vector2 with a magnitude of 1\r\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"These vector axes can also have weights, though the weights can only be values that can be multiplied by a vector. For example, you could set mouse sensitivity like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"local mouse = Axis.input {\r\n    [Enum.UserInputType.MouseMovement] = 50,\r\n    -- [Enum.UserInputType.MouseMovement] = Vector2.new(0, 1),\r\n    -- ^ You can't do this yet (as of v0.1) unfortunately\r\n}\r\nlocal delta = mouse:read() -- mouse movement is a variable-magnitude vector, but we still multiply by 50\n"})}),"\n",(0,i.jsx)(n.h2,{id:"more-information",children:"More Information"}),"\n",(0,i.jsxs)(n.p,{children:["To read about more specific features for mobile and console support, check out the device support guides, or check out the ",(0,i.jsx)(n.a,{href:"../../api/Axis",children:"API"})," to start using Axis."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"../Devices/touch",children:"Touch"}),": ",(0,i.jsx)(n.code,{children:"hold()"})," and ",(0,i.jsx)(n.code,{children:"move()"})," for UI touch controls"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"../Devices/controller",children:"Controller"}),": controller numbers for handling multiple controllers"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"../Devices/desktop",children:"Desktop"}),": mouse stuff"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var s=t(6540);const i={},r=s.createContext(i);function a(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);