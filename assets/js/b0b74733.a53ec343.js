"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[637],{6584:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>a,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"Introduction/example_game","title":"Example Game","description":"Official example game","source":"@site/docs/Introduction/example_game.md","sourceDirName":"Introduction","slug":"/Introduction/example_game","permalink":"/Axis/docs/Introduction/example_game","draft":false,"unlisted":false,"editUrl":"https://github.com/NeonD00m/axis/edit/main/docs/Introduction/example_game.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Example Game","description":"Official example game","sidebar_position":3},"sidebar":"defaultSidebar","previous":{"title":"Best Practices","permalink":"/Axis/docs/Introduction/best_practices"},"next":{"title":"Desktop","permalink":"/Axis/docs/Devices/desktop"}}');var r=t(4848),i=t(8453);const a={title:"Example Game",description:"Official example game",sidebar_position:3},s="Example Game",l={},c=[{value:"Behind The Scenes",id:"behind-the-scenes",level:3},{value:"Toggleable Crouch",id:"toggleable-crouch",level:3},{value:"Hold-to-Jump",id:"hold-to-jump",level:3},{value:"Camera Movement",id:"camera-movement",level:3},{value:"Camera Zoom",id:"camera-zoom",level:3}];function u(e){const n={a:"a",code:"code",h1:"h1",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"example-game",children:"Example Game"})}),"\n",(0,r.jsxs)(n.p,{children:["Play the example game ",(0,r.jsx)(n.a,{href:"http://rblx.games/119823868761655",children:"here"}),"\r\nThis article features abridged samples of the actual code in the example game, but you can view the full code ",(0,r.jsx)(n.a,{href:"https://github.com/NeonD00m/Axis/tree/main/exampleGame/client",children:"here"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"behind-the-scenes",children:"Behind The Scenes"}),"\n",(0,r.jsx)(n.p,{children:"The concept for this game was to implement three simple mechanics with Axis:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Toggleable crouch button for mobile"}),"\n",(0,r.jsx)(n.li,{children:"A hold-to-jump mechanic for all platforms"}),"\n",(0,r.jsxs)(n.li,{children:["Custom camera (to show how to use mouse input, ",(0,r.jsx)(n.code,{children:"hold()"}),", and throw console support in there)"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"THe above order is also the order in which the features will be explained in to roughly go from least to most complex."}),"\n",(0,r.jsx)(n.h3,{id:"toggleable-crouch",children:"Toggleable Crouch"}),"\n",(0,r.jsx)(n.p,{children:"Alright so here is the actual keymap for the crouching feature. We include all the possible keyboard keys that people might use, as well as the right thumbstick for console. Mobile will be implemented separately."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"--inputMap.luau\r\ncrouch = input {\r\n    Enum.KeyCode.C,\r\n    Enum.KeyCode.LeftControl,\r\n    Enum.KeyCode.RightControl,\r\n    Enum.KeyCode.ButtonR3, -- pressing on the right thumbstick will crouch!\r\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Now we're going to write our crouch system in a way that it will work for all devices without needing to handle any input logic specific to any device:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"--crouch.luau\r\nlocal crouching = false\r\n\r\nlocal function crouch(dt)\r\n    -- other if statements\r\n\r\n    if not inputMap.crouch:pressed() then\r\n        return\r\n    end\r\n\r\n    crouching = not crouching\r\n    -- humanoid effects\r\nend\n"})}),"\n",(0,r.jsxs)(n.p,{children:["All we have to do is wait for the ",(0,r.jsx)(n.code,{children:"pressed()"})," method to signal that the input was just toggled. You could also use ",(0,r.jsx)(n.code,{children:"released()"})," to toggle on release but it might feel delayed from a player's perspective."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"--touchControls.luau\r\nlocal crouching = false\r\n\r\ncrouchButton.MouseButton1Down:Connect(function()\r\n    inputMap.crouch:move(1)\r\n    crouching = not crouching\r\n    if not crouching then\r\n        -- UI effects\r\n        return\r\n    end\r\n    -- UI effects\r\nend)\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Since we know that we just want the crouch to be toggleable, we will implement it with ",(0,r.jsx)(n.code,{children:"move()"})," to fire the ",(0,r.jsx)(n.code,{children:"pressed()"})," method, but you might not always want to make this assumption. If you wanted to make it hold-to-crouch, or add a setting for whether it is toggleable, you would want to implement the button using ",(0,r.jsx)(n.code,{children:"hold()"})," as seen in the ",(0,r.jsx)(n.a,{href:"./example_game#hold-to-jump",children:"next section"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"hold-to-jump",children:"Hold-to-Jump"}),"\n",(0,r.jsx)(n.p,{children:"Since we just saw the basic implementation of the crouch button, let's jump into the implementation of the hold-to-jump button. Here we are using a different method of handling input on the touch button to allow for mobile users to drag and move the camera around while holding the button."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"local releaseJump, touch = nil, nil\r\n\r\njumpButton.InputBegan:Connect(function(input)\r\n    if input.UserInputType ~= Enum.UserInputType.MouseButton1 and\r\n        input.UserInputType ~= Enum.UserInputType.Touch then\r\n        return\r\n    end\r\n    if input.UserInputState ~= Enum.UserInputState.Begin then\r\n        return\r\n    end\r\n\r\n    touch = input\r\n    releaseJump = inputMap.jump:hold(1) -- imitates pressing an input axis like the `Space` key\r\n    -- UI effects\r\nend)\r\n\r\nUserInputService.InputEnded:Connect(function(input)\r\n    if not releaseJump or input ~= touch or input.UserInputState ~= Enum.UserInputState.End then\r\n        return\r\n    end\r\n    if input.UserInputType ~= Enum.UserInputType.MouseButton1 and\r\n        input.UserInputType ~= Enum.UserInputType.Touch then\r\n        return\r\n    end\r\n\r\n    releaseJump() -- releases the hold, imitating letting go of the `Space` key\r\n    releaseJump = nil\r\n    -- UI effects\r\nend)\n"})}),"\n",(0,r.jsxs)(n.p,{children:["This method of input only successfully allows for dragging when the button's ",(0,r.jsx)(n.code,{children:"Active"})," property is set to false and ",(0,r.jsx)(n.code,{children:"Interactable"})," is set to true. If ",(0,r.jsx)(n.code,{children:"Active"})," is on, touching the button will be considered a 'processed' input and ignored by most input systems. If ",(0,r.jsx)(n.code,{children:"Interactable"})," is off, events like ",(0,r.jsx)(n.code,{children:"InputBegan"})," will not be fired. Anyway, for reference, here is what the actual input axis looks like for other devices:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"jump = Axis.input {\r\n    Enum.KeyCode.Space,\r\n    Enum.KeyCode.ButtonA\r\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Now for the system to handle the jumping feature. This will be a bit more complicated than the crouch button, since the goal is to let the user hold the jump button for longer to jump higher. We will start by creating a variable called ",(0,r.jsx)(n.code,{children:"jumpHoldTime"})," that will keep track of how long the player has held the jump input axis for."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"local jumpHoldTime = 0\n"})}),"\n",(0,r.jsx)(n.p,{children:"Then in our jump system the first thing we want to do is check if the player should even be able to jump."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"-- if the player is swimming or falling or climbing, reset jump power\r\nif humanoid:GetState() ~= Enum.HumanoidStateType.Running then\r\n    jumpHoldTime = 0\r\n    return -- end system early\r\nend\n"})}),"\n",(0,r.jsx)(n.p,{children:"Now since we know that the player is in a valid state to jump (they are standing on the ground), we can check if the jump button was released."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"if inputMap.jump:released() then -- when the jump axis changed and is not held any more\r\n    humanoid.JumpPower = getJumpPower() -- our custom equation using jumpHoldTime\r\n    humanoid:ChangeState(Enum.HumanoidStateType.Jumping)\r\n    jumpHoldTime = 0\r\n    return -- end early again\r\nend\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Then we will finish the system off with the following code for incrementing our timer ",(0,r.jsx)(n.code,{children:"jumpHoldTime"})," (and setting the jump power to 0 to stop the player from jumping)."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"humanoid.JumpPower = 0\r\njumpHoldTime = inputMap.jump:pressing() and (jumpHoldTime or 0) + deltaTime\n"})}),"\n",(0,r.jsx)(n.h3,{id:"camera-movement",children:"Camera Movement"}),"\n",(0,r.jsxs)(n.p,{children:["Note: This camera system uses the ",(0,r.jsx)(n.a,{href:"https://quenty.github.io/NevermoreEngine/api/Spring/",children:"Nevermore Spring"})," to smooth out the camera movement."]}),"\n",(0,r.jsx)(n.p,{children:"In your game, there is a good chance that your systems that handle camera movement or unique camera modes might not want to all handle input manually, this is where Axis can help by using only two input axes."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"local inputMap = {\r\n    -- ...\r\n    drag = input {\r\n        Enum.UserInputType.MouseMovement,\r\n        Enum.KeyCode.Thumbstick2,\r\n\t\t[Enum.KeyCode.Left] = vector.create(-2, 0),\r\n\t\t[Enum.KeyCode.Right] = vector.create(2, 0),\r\n    },\r\n\tdragHold = input {\r\n        Enum.UserInputType.MouseButton2\r\n    },\r\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Above you'll see we have the main ",(0,r.jsx)(n.code,{children:"drag"})," input and a secondary ",(0,r.jsx)(n.code,{children:"dragHold"})," input. The ",(0,r.jsx)(n.code,{children:"drag"})," input will be used for general camera movement, while the ",(0,r.jsx)(n.code,{children:"dragHold"}),' input will be used to hold the mouse in place and allow the mouse to be "unlocked" the rest of the time.']}),"\n",(0,r.jsx)(n.h3,{id:"camera-zoom",children:"Camera Zoom"}),"\n",(0,r.jsx)(n.p,{children:"Here is where the weighting of input axes comes in handy. Using another unnamed input library, we were handling sensitivities for the zoom something like this:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"--camera.luau\r\nlocal ZOOM_SPEED = {\r\n\tTouch = 5,\r\n\tGamepad = 2,\r\n\tDesktop = 10,\r\n}\r\n\r\nlocal function clampZoom(zoom: number): number\r\n\treturn math.clamp(offsetVector.Position.Z - zoom \r\n\t\t* ZOOM_SPEED[axis.device(UserInputService:GetLastInputType())],\r\n\t\tMIN_ZOOM, MAX_ZOOM\r\n\t)\r\nend\n"})}),"\n",(0,r.jsx)(n.p,{children:"We can start to reduce this code by putting gamepad and desktop sensitivities in the same input axis:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"--inputMap.luau\r\nzoom = input {\r\n    [Enum.KeyCode.DPadDown] = -2,\r\n    [Enum.KeyCode.DPadUp] = 2,\r\n    [Enum.KeyCode.I] = 2,\r\n    [Enum.KeyCode.O] = -2,\r\n    [Enum.UserInputType.MouseWheel] = 10,  \r\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Now we can use a constant in the mobile input system to add that extra sensitivity:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"--mobileInput.luau\r\nlocal PINCH_MULTI = 50\r\n\r\nUserInputService.TouchPinch:Connect(function(_, scale, _, _, _) \r\n\t-- other logic\r\n    inputMap.zoom:move((scale - previousScale) * PINCH_MULTI)\r\n\t-- other logic\r\nend)\n"})}),"\n",(0,r.jsx)(n.p,{children:"Then we can just completely forget about handling different devices in the camera system!"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"local function clampZoom(zoom: number): number\r\n\treturn math.clamp(offsetVector.Position.Z - zoom, MIN_ZOOM, MAX_ZOOM)\r\nend\n"})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>s});var o=t(6540);const r={},i=o.createContext(r);function a(e){const n=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),o.createElement(i.Provider,{value:n},e.children)}}}]);