{"searchDocs":[{"title":"Glossary","type":0,"sectionRef":"#","url":"/Axis/docs/intro","content":"Glossary Here's a quick navigation of Planck's Docs. Introduction​ Getting StartedBest PracticesExample Game Devices​ DesktopControllerTouch API​ AxisInput","keywords":"","version":"Next"},{"title":"Axis","type":0,"sectionRef":"#","url":"/Axis/api/Axis","content":"","keywords":"","version":null},{"title":"Types​","type":1,"pageTitle":"Axis","url":"/Axis/api/Axis#types","content":" ","version":null,"tagName":"h2"},{"title":"DeviceType​","type":1,"pageTitle":"Axis","url":"/Axis/api/Axis#DeviceType","content":"&lt;/&gt; type DeviceType = &quot;Desktop&quot; | &quot;Touch&quot; | &quot;Controller&quot;  ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"Axis","url":"/Axis/api/Axis#functions","content":" ","version":null,"tagName":"h2"},{"title":"input​","type":1,"pageTitle":"Axis","url":"/Axis/api/Axis#input","content":"&lt;/&gt; Axis.input(keyMap: Map&lt;T&gt;) → Input&lt;T&gt; ","version":null,"tagName":"h3"},{"title":"Types","type":1,"pageTitle":"Axis","url":"/Axis/api/Axis##","content":"","version":null,"tagName":"h3"},{"title":"​","type":1,"pageTitle":"Axis","url":"/Axis/api/Axis#Map<T>","content":"type Map&lt;T&gt; = {[Enum | string]: T} &amp; {Enum.KeyCode | Enum.UserInputType}  Creates a new input axis with the provided keymap local attack = Axis.input { Enum.KeyCode.E, Enum.KeyCode.ButtonX, }   ","version":null,"tagName":"h3"},{"title":"update​","type":1,"pageTitle":"Axis","url":"/Axis/api/Axis#update","content":"&lt;/&gt; Axis.update() → () Updates all the provided inputs as a shorthand Axis.update(inputMap)   ","version":null,"tagName":"h3"},{"title":"device​","type":1,"pageTitle":"Axis","url":"/Axis/api/Axis#device","content":"&lt;/&gt; Axis.device() → () Gets the device of the provided UserInputType (or the last UserInputType if none is provided) local device = Axis.device() --gets device of last input if device == &quot;Desktop&quot; then print(&quot;yay&quot;) end  ","version":null,"tagName":"h3"},{"title":"Input","type":0,"sectionRef":"#","url":"/Axis/api/Input","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"Input","url":"/Axis/api/Input#functions","content":" ","version":null,"tagName":"h2"},{"title":"read​","type":1,"pageTitle":"Input","url":"/Axis/api/Input#read","content":"&lt;/&gt; Input:read(controller: number?) → T,T Reads current and previous values for the axis local current, previous = attack:read()   ","version":null,"tagName":"h3"},{"title":"pressing​","type":1,"pageTitle":"Input","url":"/Axis/api/Input#pressing","content":"&lt;/&gt; Input:pressing(controller: number?) → boolean Gets whether the axis has any active input  ","version":null,"tagName":"h3"},{"title":"changed​","type":1,"pageTitle":"Input","url":"/Axis/api/Input#changed","content":"&lt;/&gt; Input:changed(controller: number?) → boolean Gets whether an axis has changed since the last update  ","version":null,"tagName":"h3"},{"title":"pressed​","type":1,"pageTitle":"Input","url":"/Axis/api/Input#pressed","content":"&lt;/&gt; Input:pressed(controller: number?) → boolean Gets whether the axis was activated this update  ","version":null,"tagName":"h3"},{"title":"released​","type":1,"pageTitle":"Input","url":"/Axis/api/Input#released","content":"&lt;/&gt; Input:released(controller: number?) → boolean Gets whether the axis was deactivated this update  ","version":null,"tagName":"h3"},{"title":"hold​","type":1,"pageTitle":"Input","url":"/Axis/api/Input#hold","content":"&lt;/&gt; Input:hold( value: T, controller: number? ) → () → () Adds a temporary manual input to the axis, and provides a function to release it local release = attack:hold(1) -- adds 1 to the axis --release later release() -- removes the added value   ","version":null,"tagName":"h3"},{"title":"move​","type":1,"pageTitle":"Input","url":"/Axis/api/Input#move","content":"&lt;/&gt; Input:move( value: T, controller: number? ) → () Adds an input to the axis for a single frame  ","version":null,"tagName":"h3"},{"title":"map​","type":1,"pageTitle":"Input","url":"/Axis/api/Input#map","content":"&lt;/&gt; Input:map(keyMap: Map&lt;T&gt;) → () Maps input types to an input axis attack:map { Enum.KeyCode.Q, Enum.KeyCode.ButtonA, } -- or to clear all input mappings attack:map {}   ","version":null,"tagName":"h3"},{"title":"update​","type":1,"pageTitle":"Input","url":"/Axis/api/Input#update","content":"&lt;/&gt; Input:update() → () Updates the current and previous values of the input axis ","version":null,"tagName":"h3"},{"title":"Touch","type":0,"sectionRef":"#","url":"/Axis/docs/Devices/touch","content":"Touch WIP","keywords":"","version":"Next"},{"title":"Desktop","type":0,"sectionRef":"#","url":"/Axis/docs/Devices/desktop","content":"Desktop WIP","keywords":"","version":"Next"},{"title":"Best Practices","type":0,"sectionRef":"#","url":"/Axis/docs/Introduction/best_practices","content":"Best Practices You have two main options while using Axis, you can either collect all your input axes in a single module for other systems to require, or you can define them in the systems that need them (may create redundancy). local inputDelta = Axis.input { Enum.UserInputType.MouseMovement, [Enum.KeyCode.Thumbstick1] = 20, } local function camera() ... end OR local inputMap = { inputDelta = Axis.input { Enum.UserInputType.MouseMovement, [Enum.KeyCode.Thumbstick1] = 20, }, attack = Axis.input { Enum.KeyCode.E, Enum.KeyCode.ButtonA, }, block = Axis.input { Enum.KeyCode.F, }, } return inputMap Of course you can do something in between but at killer.gg we have found that containing all the input axes in a single module is the best option, since it allows us to easily access all of them in other systems (see mobileInput.luau and camera.luau in the example game). More stuff soon probably","keywords":"","version":"Next"},{"title":"Example Game","type":0,"sectionRef":"#","url":"/Axis/docs/Introduction/example_game","content":"","keywords":"","version":"Next"},{"title":"Behind The Scenes​","type":1,"pageTitle":"Example Game","url":"/Axis/docs/Introduction/example_game#behind-the-scenes","content":" See the code either by downloading the reposity or reading it on github. ","version":"Next","tagName":"h2"},{"title":"Controller","type":0,"sectionRef":"#","url":"/Axis/docs/Devices/controller","content":"Controller WIP","keywords":"","version":"Next"},{"title":"Getting Started","type":0,"sectionRef":"#","url":"/Axis/docs/Introduction/getting_started","content":"","keywords":"","version":"Next"},{"title":"Installation​","type":1,"pageTitle":"Getting Started","url":"/Axis/docs/Introduction/getting_started#installation","content":" Currently only available on pesde  ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"Getting Started","url":"/Axis/docs/Introduction/getting_started#usage","content":" While this library is agnostic and doesn't require an ECS of any sort, it is definitely ECS-oriented since its meant to be run in systems. Input axes run on a frame by frame basis, meaning they need to be updated every frame.  while wait() do attack:update() -- update the input axes if attack:pressed() then -- fires once, when the input is newly pressed print(&quot;Attacked!&quot;) end end   ","version":"Next","tagName":"h2"},{"title":"Input Axes​","type":1,"pageTitle":"Getting Started","url":"/Axis/docs/Introduction/getting_started#input-axes","content":" To create an input axis, you need to define a keymap. These keymaps can contain keybinds for any devices, as shown here:  local attack = Axis.input { Enum.KeyCode.E, -- for keyboard, though usually redundant with mouse Enum.UserInputType.MouseButton1, -- for mouse Enum.KeyCode.ButtonR2, -- for xbox/ps4 controllers }   In this example, three axes have been defined in the input, E, left click, and the right trigger on console. These axes for example are all positive (by default), meaning that each can either be equal to 0 or 1.  -- if any of the axes are equal to 1, the input is considered pressing if attack:pressing() then ...   But lets use this idea of axes to use the mouse's scroll wheel as input. The scroll wheel is a special key where the value can either be 0 (for no scroll), 1 (for scrolling up), or -1 (for scrolling down). This means that the axis could be negative or positive.  local zoom = Axis.input { Enum.UserInputType.MouseWheel }   In this case, pressing == when the user is scrolling in either direction. (Pressing is true when the whole input is not equal to 0, this is called being &quot;activated&quot; in the API).  local pressing = zoom:pressing()   So now, using read() is more useful, since it returns the current and previous values of the axis.  local current, previous = zoom:read() -- current will equal either, -1, 0, or 1 -- same for previous!   ","version":"Next","tagName":"h3"},{"title":"Axis Weights​","type":1,"pageTitle":"Getting Started","url":"/Axis/docs/Introduction/getting_started#axis-weights","content":" By default input axes are given a weight of 1. This means that if one axis was positive and another was negative, they would cancel each other out.  local movementIn2D = Axis.input { [Enum.KeyCode.A] = -1, Enum.KeyCode.D, -- by default, given a weight of positive 1 -- [Enum.KeyCode.D] = 1, -- this is explicit, but has same behavior }   If both keys were being pressed at the same time, the value of the input as a whole would be 0, since 1 + (-1) = 0. This is how input is calculated internally- it's just a sum of all the axes. You could weight axes very differently, if you wanted:  local acceleratePedal = Axis.input { [Enum.KeyCode.Q] = 3, [Enum.KeyCode.W] = 1, } local pedal = acceleratePedal:read() -- pedal will equal either 4, 3, 1, or 0   warning Beware of using variable magnitude weights when reading with read() as you may get unexpected results. Remember that the result of read() is a sum of all the axes, so the value have a magnitude of more than 1 or less than -1.  ","version":"Next","tagName":"h3"},{"title":"Vector Axes​","type":1,"pageTitle":"Getting Started","url":"/Axis/docs/Introduction/getting_started#vector-axes","content":" The cool thing about modelling input as axes is that they can be vectors. For example, the common usecase of character movement with WASD:  local move = Axis.input { [Enum.KeyCode.W] = Vector2.new(0, 1), [Enum.KeyCode.S] = Vector2.new(0, -1), [Enum.KeyCode.A] = Vector2.new(-1, 0), [Enum.KeyCode.D] = Vector2.new(1, 0), }   But then you can also add support for the thumbsticks:  ... [Enum.KeyCode.D] = Vector2.new(1, 0), Enum.KeyCode.Thumbstick1, -- could be any Vector2 with a magnitude of 1 }   These vector axes can also have weights, though the weights can only be values that can be multiplied by a vector. For example, you could set mouse sensitivity like this:  local mouse = Axis.input { [Enum.UserInputType.MouseMovement] = 50, -- [Enum.UserInputType.MouseMovement] = Vector2.new(0, 1), -- ^ You can't do this yet (as of v0.1) unfortunately } local delta = mouse:read() -- mouse movement is a variable-magnitude vector, but we still multiply by 50   ","version":"Next","tagName":"h3"},{"title":"More Information​","type":1,"pageTitle":"Getting Started","url":"/Axis/docs/Introduction/getting_started#more-information","content":" To read about more specific features for mobile and console support, check out the device support guides, or check out the API to start using Axis.  Touch: hold() for UI touch controlsController: move() for adding an input value for a single frameDesktop: mouse stuff ","version":"Next","tagName":"h2"}],"options":{"id":"default"}}