{"searchDocs":[{"title":"Glossary","type":0,"sectionRef":"#","url":"/Axis/docs/intro","content":"Glossary Here's a quick navigation of Axis' Docs. Introduction​ Getting StartedBest PracticesExample Game Devices​ DesktopControllerTouch API​ AxisInput","keywords":"","version":"Next"},{"title":"Desktop","type":0,"sectionRef":"#","url":"/Axis/docs/Devices/desktop","content":"Desktop WIP","keywords":"","version":"Next"},{"title":"Controller","type":0,"sectionRef":"#","url":"/Axis/docs/Devices/controller","content":"Controller If you have taken the time to read through the API, you may have noticed that most methods have a controller parameter with the type of number?. Roblox supports up to 8 &quot;gamepads&quot; and as such, your game may experience up to 8 controllers (and you may want to support this by having different input axes for each controller). local jump = Axis.input { Enum.KeyCode.Space, -- any other inputs will be treated as controller 1 Enum.KeyCode.ButtonA, } In this example, let's say that we let 8 players play locally, each with their own character who may want to jump for whatever reason. You may write a system like this to handle each character: local function jump() for i = 1, 8 do -- if standing on the ground ... if jump:pressed(i) then -- make their character jump end end end Remember that you can use UserInputService:GetConnectedGamepads() to get the number of connected controllers. Almost all methods allow you to specify a controller like this, even move(), hold(), and read().","keywords":"","version":"Next"},{"title":"Axis","type":0,"sectionRef":"#","url":"/Axis/api/Axis","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"Axis","url":"/Axis/api/Axis#functions","content":" ","version":null,"tagName":"h2"},{"title":"input​","type":1,"pageTitle":"Axis","url":"/Axis/api/Axis#input","content":"&lt;/&gt; Axis.input(keyMap: Map&lt;T&gt;) → Input&lt;T&gt; ","version":null,"tagName":"h3"},{"title":"Types","type":1,"pageTitle":"Axis","url":"/Axis/api/Axis##","content":"","version":null,"tagName":"h3"},{"title":"​","type":1,"pageTitle":"Axis","url":"/Axis/api/Axis#Map<T>","content":"type Map&lt;T&gt; = {[Enum | string]: T} &amp; {Enum.KeyCode | Enum.UserInputType}  Creates a new input axis with the provided keymap local attack = Axis.input { Enum.KeyCode.E, Enum.KeyCode.ButtonX, }   ","version":null,"tagName":"h3"},{"title":"update​","type":1,"pageTitle":"Axis","url":"/Axis/api/Axis#update","content":"&lt;/&gt; Axis.update() → () Updates all the provided inputs as a shorthand Axis.update(inputMap)   ","version":null,"tagName":"h3"},{"title":"device​","type":1,"pageTitle":"Axis","url":"/Axis/api/Axis#device","content":"&lt;/&gt; Axis.device(input: Enum.UserInputType?) → DeviceType ","version":null,"tagName":"h3"},{"title":"Types","type":1,"pageTitle":"Axis","url":"/Axis/api/Axis##","content":"","version":null,"tagName":"h3"},{"title":"​","type":1,"pageTitle":"Axis","url":"/Axis/api/Axis#DeviceType","content":"type DeviceType = &quot;Desktop&quot; | &quot;Touch&quot; | &quot;Controller&quot;  Gets the device of the provided UserInputType (or the last UserInputType if none is provided) local device = Axis.device() --gets device of last input if device == &quot;Desktop&quot; then print(&quot;yay&quot;) end  ","version":null,"tagName":"h3"},{"title":"Touch","type":0,"sectionRef":"#","url":"/Axis/docs/Devices/touch","content":"","keywords":"","version":"Next"},{"title":"Hold​","type":1,"pageTitle":"Touch","url":"/Axis/docs/Devices/touch#hold","content":" Holding is the easiest method of using UI touch controls with Axis. When you write your keymap, you won't be able to use any sort of special keys for mobile in most cases, so you implement it as usual for other devices.  local aim = Axis.input { Enum.UserInputType.MouseButton2, Enum.KeyCode.ButtonL2 }   In this example, we're going to be writing support for aiming down sights (ADS) in an FPS game. Imagine we have the following ADS system to handle the visuals:  local function aimDownSights() aim:update() local isAiming: number = if aim:pressed() then 1 else 0 local gunOffset = hipOffset:Lerp(aimOffset, isAiming) ... end   After designing a UI button (aimButton) for mobile players, we can use hold() to add the input value to the axis:  local release, touch = nil, nil aimButton.InputBegan:Connect(function(input) if input.UserInputType ~= Enum.UserInputType.MouseButton1 and input.UserInputType ~= Enum.UserInputType.Touch then return end if input.UserInputState ~= Enum.UserInputState.Begin then return end touch = input release = aim:hold() -- this sets the value of the aim input to 1, as if there was a right click end) UserInputService.InputEnded:Connect(function(input) if not releaseJump or input ~= touch or input.UserInputState ~= Enum.UserInputState.End then return end if input.UserInputType ~= Enum.UserInputType.MouseButton1 and input.UserInputType ~= Enum.UserInputType.Touch then return end release() -- this releases the hold, as if the right click was released release = nil end)   This code would make sure that your game can properly support mobile players with intuitive controls, while keeping input handling outside of your game logic (in this case, the aimDownSights() function).  tip You may be wondering why we're using this complicated method instead of aimButton.Activated. Well this strategy is to allow mobile players to continue to drag their camera around while pressing the button (and holding the input axis). This is ideal in a scenario where the gun might shoot automatically when aiming over a player on a mobile device. But this is more common with 'shoot' buttons.  ","version":"Next","tagName":"h3"},{"title":"Move​","type":1,"pageTitle":"Touch","url":"/Axis/docs/Devices/touch#move","content":" If you are using a UI framework like Roact or Vide, or maybe you just have state in a different library, you may want to have a system run every frame that uses move() to connect that state to an input axis.  local isShootButtonPressed -- state that comes from somewhere else local shoot = Axis.input { Enum.KeyCode.ButtonR2, Enum.KeyCode.MouseButton1 } local function handleInput() if isShootButtonPressed() then shoot:move(1) end -- maybe do the same for other input axes end   move() works just like a hold(), except that it is optimized to only add that value to the axis for a single update. This works in this situation since you can only check whether the button is pressed every frame, so it makes sense to just move the axis for that frame and then have it reset automatically the next frame. ","version":"Next","tagName":"h3"},{"title":"Input","type":0,"sectionRef":"#","url":"/Axis/api/Input","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"Input","url":"/Axis/api/Input#functions","content":" ","version":null,"tagName":"h2"},{"title":"read​","type":1,"pageTitle":"Input","url":"/Axis/api/Input#read","content":"&lt;/&gt; Input:read(controller: number?) → T,T Reads current and previous values for the axis local current, previous = attack:read()   ","version":null,"tagName":"h3"},{"title":"pressing​","type":1,"pageTitle":"Input","url":"/Axis/api/Input#pressing","content":"&lt;/&gt; Input:pressing(controller: number?) → boolean Gets whether the axis has any active input  ","version":null,"tagName":"h3"},{"title":"changed​","type":1,"pageTitle":"Input","url":"/Axis/api/Input#changed","content":"&lt;/&gt; Input:changed(controller: number?) → boolean Gets whether an axis has changed since the last update  ","version":null,"tagName":"h3"},{"title":"pressed​","type":1,"pageTitle":"Input","url":"/Axis/api/Input#pressed","content":"&lt;/&gt; Input:pressed(controller: number?) → boolean Gets whether the axis was activated this update  ","version":null,"tagName":"h3"},{"title":"released​","type":1,"pageTitle":"Input","url":"/Axis/api/Input#released","content":"&lt;/&gt; Input:released(controller: number?) → boolean Gets whether the axis was deactivated this update  ","version":null,"tagName":"h3"},{"title":"hold​","type":1,"pageTitle":"Input","url":"/Axis/api/Input#hold","content":"&lt;/&gt; Input:hold( value: T, controller: number? ) → () → () Adds a temporary manual input to the axis, and provides a function to release it local release = attack:hold(1) -- adds 1 to the axis --release later release() -- removes the added value   ","version":null,"tagName":"h3"},{"title":"move​","type":1,"pageTitle":"Input","url":"/Axis/api/Input#move","content":"&lt;/&gt; Input:move( value: T, controller: number? ) → () Adds an input to the axis for a single frame  ","version":null,"tagName":"h3"},{"title":"map​","type":1,"pageTitle":"Input","url":"/Axis/api/Input#map","content":"&lt;/&gt; Input:map(keyMap: Map&lt;T&gt;) → () Maps input types to an input axis attack:map { Enum.KeyCode.Q, Enum.KeyCode.ButtonA, } -- or to clear all input mappings attack:map {}   ","version":null,"tagName":"h3"},{"title":"update​","type":1,"pageTitle":"Input","url":"/Axis/api/Input#update","content":"&lt;/&gt; Input:update() → () Updates the current and previous values of the input axis ","version":null,"tagName":"h3"},{"title":"Best Practices","type":0,"sectionRef":"#","url":"/Axis/docs/Introduction/best_practices","content":"Best Practices You have two main options while using Axis, you can either collect all your input axes in a single module for other systems to require, or you can define them in the systems that need them (may create redundancy). local inputDelta = Axis.input { Enum.UserInputType.MouseMovement, [Enum.KeyCode.Thumbstick1] = 20, } local function camera() ... end OR local inputMap = { inputDelta = Axis.input { Enum.UserInputType.MouseMovement, [Enum.KeyCode.Thumbstick1] = 20, }, attack = Axis.input { Enum.KeyCode.E, Enum.KeyCode.ButtonA, }, block = Axis.input { Enum.KeyCode.F, }, } return inputMap Of course you can do something in between but at killer.gg we have found that containing all the input axes in a single module is the best option, since it allows us to easily access all of them in other systems (see mobileInput.luau and camera.luau in the example game). More stuff soon probably","keywords":"","version":"Next"},{"title":"Example Game","type":0,"sectionRef":"#","url":"/Axis/docs/Introduction/example_game","content":"","keywords":"","version":"Next"},{"title":"Behind The Scenes​","type":1,"pageTitle":"Example Game","url":"/Axis/docs/Introduction/example_game#behind-the-scenes","content":" The concept for this game was to implement three simple mechanics with Axis:  Toggleable crouch button for mobileA hold-to-jump mechanic for all platformsCustom camera (to show how to use mouse input, hold(), and throw console support in there)  THe above order is also the order in which the features will be explained in to roughly go from least to most complex.  ","version":"Next","tagName":"h3"},{"title":"Toggleable Crouch​","type":1,"pageTitle":"Example Game","url":"/Axis/docs/Introduction/example_game#toggleable-crouch","content":" Alright so here is the actual keymap for the crouching feature. We include all the possible keyboard keys that people might use, as well as the right thumbstick for console. Mobile will be implemented separately.  --inputMap.luau crouch = input { Enum.KeyCode.C, Enum.KeyCode.LeftControl, Enum.KeyCode.RightControl, Enum.KeyCode.ButtonR3, -- pressing on the right thumbstick will crouch! }   Now we're going to write our crouch system in a way that it will work for all devices without needing to handle any input logic specific to any device:  --crouch.luau local crouching = false local function crouch(dt) -- other if statements if not inputMap.crouch:pressed() then return end crouching = not crouching -- humanoid effects end   All we have to do is wait for the pressed() method to signal that the input was just toggled. You could also use released() to toggle on release but it might feel delayed from a player's perspective.  --touchControls.luau local crouching = false crouchButton.MouseButton1Down:Connect(function() inputMap.crouch:move(1) crouching = not crouching if not crouching then -- UI effects return end -- UI effects end)   Since we know that we just want the crouch to be toggleable, we will implement it with move() to fire the pressed() method, but you might not always want to make this assumption. If you wanted to make it hold-to-crouch, or add a setting for whether it is toggleable, you would want to implement the button using hold() as seen in the next section.  ","version":"Next","tagName":"h3"},{"title":"Hold-to-Jump​","type":1,"pageTitle":"Example Game","url":"/Axis/docs/Introduction/example_game#hold-to-jump","content":" Since we just saw the basic implementation of the crouch button, let's jump into the implementation of the hold-to-jump button. Here we are using a different method of handling input on the touch button to allow for mobile users to drag and move the camera around while holding the button.  local releaseJump, touch = nil, nil jumpButton.InputBegan:Connect(function(input) if input.UserInputType ~= Enum.UserInputType.MouseButton1 and input.UserInputType ~= Enum.UserInputType.Touch then return end if input.UserInputState ~= Enum.UserInputState.Begin then return end touch = input releaseJump = inputMap.jump:hold(1) -- imitates pressing an input axis like the `Space` key -- UI effects end) UserInputService.InputEnded:Connect(function(input) if not releaseJump or input ~= touch or input.UserInputState ~= Enum.UserInputState.End then return end if input.UserInputType ~= Enum.UserInputType.MouseButton1 and input.UserInputType ~= Enum.UserInputType.Touch then return end releaseJump() -- releases the hold, imitating letting go of the `Space` key releaseJump = nil -- UI effects end)   This method of input only successfully allows for dragging when the button's Active property is set to false and Interactable is set to true. If Active is on, touching the button will be considered a 'processed' input and ignored by most input systems. If Interactable is off, events like InputBegan will not be fired. Anyway, for reference, here is what the actual input axis looks like for other devices:  jump = Axis.input { Enum.KeyCode.Space, Enum.KeyCode.ButtonA }   Now for the system to handle the jumping feature. This will be a bit more complicated than the crouch button, since the goal is to let the user hold the jump button for longer to jump higher. We will start by creating a variable called jumpHoldTime that will keep track of how long the player has held the jump input axis for.  local jumpHoldTime = 0   Then in our jump system the first thing we want to do is check if the player should even be able to jump.  -- if the player is swimming or falling or climbing, reset jump power if humanoid:GetState() ~= Enum.HumanoidStateType.Running then jumpHoldTime = 0 return -- end system early end   Now since we know that the player is in a valid state to jump (they are standing on the ground), we can check if the jump button was released.  if inputMap.jump:released() then -- when the jump axis changed and is not held any more humanoid.JumpPower = getJumpPower() -- our custom equation using jumpHoldTime humanoid:ChangeState(Enum.HumanoidStateType.Jumping) jumpHoldTime = 0 return -- end early again end   Then we will finish the system off with the following code for incrementing our timer jumpHoldTime (and setting the jump power to 0 to stop the player from jumping).  humanoid.JumpPower = 0 jumpHoldTime = inputMap.jump:pressing() and (jumpHoldTime or 0) + deltaTime   ","version":"Next","tagName":"h3"},{"title":"Camera Movement​","type":1,"pageTitle":"Example Game","url":"/Axis/docs/Introduction/example_game#camera-movement","content":" Note: This camera system uses the Nevermore Spring to smooth out the camera movement.  In your game, there is a good chance that your systems that handle camera movement or unique camera modes might not want to all handle input manually, this is where Axis can help by using only two input axes.  local inputMap = { -- ... drag = input { Enum.UserInputType.MouseMovement, Enum.KeyCode.Thumbstick2, [Enum.KeyCode.Left] = vector.create(-2, 0), [Enum.KeyCode.Right] = vector.create(2, 0), }, dragHold = input { Enum.UserInputType.MouseButton2 }, }   Above you'll see we have the main drag input and a secondary dragHold input. The drag input will be used for general camera movement, while the dragHold input will be used to hold the mouse in place and allow the mouse to be &quot;unlocked&quot; the rest of the time.  ","version":"Next","tagName":"h3"},{"title":"Camera Zoom​","type":1,"pageTitle":"Example Game","url":"/Axis/docs/Introduction/example_game#camera-zoom","content":" Here is where the weighting of input axes comes in handy. Using another unnamed input library, we were handling sensitivities for the zoom something like this:  --camera.luau local ZOOM_SPEED = { Touch = 5, Gamepad = 2, Desktop = 10, } local function clampZoom(zoom: number): number return math.clamp(offsetVector.Position.Z - zoom * ZOOM_SPEED[axis.device(UserInputService:GetLastInputType())], MIN_ZOOM, MAX_ZOOM ) end   We can start to reduce this code by putting gamepad and desktop sensitivities in the same input axis:  --inputMap.luau zoom = input { [Enum.KeyCode.DPadDown] = -2, [Enum.KeyCode.DPadUp] = 2, [Enum.KeyCode.I] = 2, [Enum.KeyCode.O] = -2, [Enum.UserInputType.MouseWheel] = 10, }   Now we can use a constant in the mobile input system to add that extra sensitivity:  --mobileInput.luau local PINCH_MULTI = 50 UserInputService.TouchPinch:Connect(function(_, scale, _, _, _) -- other logic inputMap.zoom:move((scale - previousScale) * PINCH_MULTI) -- other logic end)   Then we can just completely forget about handling different devices in the camera system!  local function clampZoom(zoom: number): number return math.clamp(offsetVector.Position.Z - zoom, MIN_ZOOM, MAX_ZOOM) end  ","version":"Next","tagName":"h3"},{"title":"Getting Started","type":0,"sectionRef":"#","url":"/Axis/docs/Introduction/getting_started","content":"","keywords":"","version":"Next"},{"title":"Installation​","type":1,"pageTitle":"Getting Started","url":"/Axis/docs/Introduction/getting_started#installation","content":" Currently only available on pesde  ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"Getting Started","url":"/Axis/docs/Introduction/getting_started#usage","content":" While this library is agnostic and doesn't require an ECS of any sort, it is definitely ECS-oriented since its meant to be run in systems. Input axes run on a frame by frame basis, meaning they need to be updated every frame.  RunService.RenderStepped:Connect(function() attack:update() -- update the input axes if attack:pressed() then -- fires once, when the input is newly pressed print(&quot;Attacked!&quot;) end end)   ","version":"Next","tagName":"h2"},{"title":"Input Axes​","type":1,"pageTitle":"Getting Started","url":"/Axis/docs/Introduction/getting_started#input-axes","content":" To create an input axis, you need to define a keymap. These keymaps can contain keybinds for any devices, as shown here:  local attack = Axis.input { Enum.KeyCode.E, -- for keyboard, though usually redundant with mouse Enum.UserInputType.MouseButton1, -- for mouse Enum.KeyCode.ButtonR2, -- for xbox/ps4 controllers }   In this example, three axes have been defined in the input, E, left click, and the right trigger on console. These axes for example are all positive (by default), meaning that each can either be equal to 0 or 1.  -- if any of the above axes are equal to 1, the input is considered pressing if attack:pressing() then ...   But lets use this idea of axes to use the mouse's scroll wheel as input. The scroll wheel is a special key where the value can either be 0 (for no scroll), 1 (for scrolling up), or -1 (for scrolling down). This means that the axis could be negative or positive.  local zoom = Axis.input { Enum.UserInputType.MouseWheel }   In this case, pressing == when the user is scrolling in either direction. (Pressing is true when the whole input is not equal to 0, this is called being &quot;activated&quot; in the API).  local pressing = zoom:pressing()   So now, using read() is more useful, since it returns the current and previous values of the axis.  local current, previous = zoom:read() -- current will equal either, -1, 0, or 1 -- same for previous!   ","version":"Next","tagName":"h3"},{"title":"Axis Weights​","type":1,"pageTitle":"Getting Started","url":"/Axis/docs/Introduction/getting_started#axis-weights","content":" By default input axes are given a weight of 1. This means that if one axis was positive and another was negative, they would cancel each other out.  local movementIn2D = Axis.input { [Enum.KeyCode.A] = -1, Enum.KeyCode.D, -- by default, given a weight of positive 1 -- [Enum.KeyCode.D] = 1, -- this is explicit, but has same behavior }   If both keys were being pressed at the same time, the value of the input as a whole would be 0, since 1 + (-1) = 0. This is how input is calculated internally- it's just a sum of all the axes. You could weight axes very differently, if you wanted:  local acceleratePedal = Axis.input { [Enum.KeyCode.Q] = 3, [Enum.KeyCode.W] = 1, } local pedal = acceleratePedal:read() -- pedal will equal either 4, 3, 1, or 0   warning Beware of using variable magnitude weights when reading with read() as you may get unexpected results. Remember that the result of read() is a sum of all the axes, so the value have a magnitude of more than 1 or less than -1.  ","version":"Next","tagName":"h3"},{"title":"Vector Axes​","type":1,"pageTitle":"Getting Started","url":"/Axis/docs/Introduction/getting_started#vector-axes","content":" The cool thing about modelling input as axes is that they can be vectors. For example, the common usecase of character movement with WASD:  local move = Axis.input { [Enum.KeyCode.W] = Vector2.new(0, 1), [Enum.KeyCode.S] = Vector2.new(0, -1), [Enum.KeyCode.A] = Vector2.new(-1, 0), [Enum.KeyCode.D] = Vector2.new(1, 0), }   But then you can also add support for the thumbsticks:  ... [Enum.KeyCode.D] = Vector2.new(1, 0), Enum.KeyCode.Thumbstick1, -- could be any Vector2 with a magnitude of 1 }   These vector axes can also have weights, though the weights can only be values that can be multiplied by a vector. For example, you could set mouse sensitivity like this:  local mouse = Axis.input { [Enum.UserInputType.MouseMovement] = 50, -- [Enum.UserInputType.MouseMovement] = Vector2.new(0, 1), } local delta = mouse:read() -- mouse movement is a variable-magnitude vector, but we still multiply by 50   ","version":"Next","tagName":"h3"},{"title":"More Information​","type":1,"pageTitle":"Getting Started","url":"/Axis/docs/Introduction/getting_started#more-information","content":" To read about more specific features for mobile and console support, check out the device support guides, or check out the API to start using Axis.  Touch: hold() and move() for UI touch controlsController: controller numbers for handling multiple controllersDesktop: mouse stuff ","version":"Next","tagName":"h2"}],"options":{"id":"default"}}