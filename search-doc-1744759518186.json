{"searchDocs":[{"title":"Glossary","type":0,"sectionRef":"#","url":"/Axis/docs/intro","content":"Glossary Here's a quick navigation of Planck's Docs. Introduction​ Getting StartedBest PracticesExample Game Devices​ DesktopControllerTouch API​ AxisInput","keywords":"","version":"Next"},{"title":"Desktop","type":0,"sectionRef":"#","url":"/Axis/docs/Devices/desktop","content":"Desktop WIP","keywords":"","version":"Next"},{"title":"Axis","type":0,"sectionRef":"#","url":"/Axis/api/Axis","content":"","keywords":"","version":null},{"title":"Types​","type":1,"pageTitle":"Axis","url":"/Axis/api/Axis#types","content":" ","version":null,"tagName":"h2"},{"title":"DeviceType​","type":1,"pageTitle":"Axis","url":"/Axis/api/Axis#DeviceType","content":"&lt;/&gt; type DeviceType = &quot;Desktop&quot; | &quot;Touch&quot; | &quot;Controller&quot;  ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"Axis","url":"/Axis/api/Axis#functions","content":" ","version":null,"tagName":"h2"},{"title":"input​","type":1,"pageTitle":"Axis","url":"/Axis/api/Axis#input","content":"&lt;/&gt; Axis.input(keyMap: Map&lt;T&gt;) → Input&lt;T&gt; ","version":null,"tagName":"h3"},{"title":"Types","type":1,"pageTitle":"Axis","url":"/Axis/api/Axis##","content":"","version":null,"tagName":"h3"},{"title":"​","type":1,"pageTitle":"Axis","url":"/Axis/api/Axis#Map<T>","content":"type Map&lt;T&gt; = {[Enum | string]: T} &amp; {Enum.KeyCode | Enum.UserInputType}  Creates a new input axis with the provided keymap local attack = Axis.input { Enum.KeyCode.E, Enum.KeyCode.ButtonX, }   ","version":null,"tagName":"h3"},{"title":"update​","type":1,"pageTitle":"Axis","url":"/Axis/api/Axis#update","content":"&lt;/&gt; Axis.update() → () Updates all the provided inputs as a shorthand Axis.update(inputMap)   ","version":null,"tagName":"h3"},{"title":"device​","type":1,"pageTitle":"Axis","url":"/Axis/api/Axis#device","content":"&lt;/&gt; Axis.device() → () Gets the device of the provided UserInputType (or the last UserInputType if none is provided) local device = Axis.device() --gets device of last input if device == &quot;Desktop&quot; then print(&quot;yay&quot;) end  ","version":null,"tagName":"h3"},{"title":"Input","type":0,"sectionRef":"#","url":"/Axis/api/Input","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"Input","url":"/Axis/api/Input#functions","content":" ","version":null,"tagName":"h2"},{"title":"read​","type":1,"pageTitle":"Input","url":"/Axis/api/Input#read","content":"&lt;/&gt; Input:read(controller: number?) → T,T Reads current and previous values for the axis local current, previous = attack:read()   ","version":null,"tagName":"h3"},{"title":"pressing​","type":1,"pageTitle":"Input","url":"/Axis/api/Input#pressing","content":"&lt;/&gt; Input:pressing(controller: number?) → boolean Gets whether the axis has any active input  ","version":null,"tagName":"h3"},{"title":"changed​","type":1,"pageTitle":"Input","url":"/Axis/api/Input#changed","content":"&lt;/&gt; Input:changed(controller: number?) → boolean Gets whether an axis has changed since the last update  ","version":null,"tagName":"h3"},{"title":"pressed​","type":1,"pageTitle":"Input","url":"/Axis/api/Input#pressed","content":"&lt;/&gt; Input:pressed(controller: number?) → boolean Gets whether the axis was activated this update  ","version":null,"tagName":"h3"},{"title":"released​","type":1,"pageTitle":"Input","url":"/Axis/api/Input#released","content":"&lt;/&gt; Input:released(controller: number?) → boolean Gets whether the axis was deactivated this update  ","version":null,"tagName":"h3"},{"title":"hold​","type":1,"pageTitle":"Input","url":"/Axis/api/Input#hold","content":"&lt;/&gt; Input:hold( value: T, controller: number? ) → () → () Adds a temporary manual input to the axis, and provides a function to release it local release = attack:hold(1) -- adds 1 to the axis --release later release() -- removes the added value   ","version":null,"tagName":"h3"},{"title":"move​","type":1,"pageTitle":"Input","url":"/Axis/api/Input#move","content":"&lt;/&gt; Input:move( value: T, controller: number? ) → () Adds an input to the axis for a single frame  ","version":null,"tagName":"h3"},{"title":"map​","type":1,"pageTitle":"Input","url":"/Axis/api/Input#map","content":"&lt;/&gt; Input:map(keyMap: Map&lt;T&gt;) → () Maps input types to an input axis attack:map { Enum.KeyCode.Q, Enum.KeyCode.ButtonA, } -- or to clear all input mappings attack:map {}   ","version":null,"tagName":"h3"},{"title":"update​","type":1,"pageTitle":"Input","url":"/Axis/api/Input#update","content":"&lt;/&gt; Input:update() → () Updates the current and previous values of the input axis ","version":null,"tagName":"h3"},{"title":"Example Game","type":0,"sectionRef":"#","url":"/Axis/docs/Introduction/example_game","content":"","keywords":"","version":"Next"},{"title":"Behind The Scenes​","type":1,"pageTitle":"Example Game","url":"/Axis/docs/Introduction/example_game#behind-the-scenes","content":" See the code either by downloading the reposity or reading it on github. ","version":"Next","tagName":"h2"},{"title":"Touch","type":0,"sectionRef":"#","url":"/Axis/docs/Devices/touch","content":"","keywords":"","version":"Next"},{"title":"Hold​","type":1,"pageTitle":"Touch","url":"/Axis/docs/Devices/touch#hold","content":" Holding is the easiest method of using UI touch controls with Axis. When you write your keymap, you won't be able to use any sort of special keys for mobile in most cases, so you implement it as usual for other devices.  local aim = Axis.input { Enum.UserInputType.MouseButton2, Enum.KeyCode.ButtonL2 }   In this example, we're going to be writing support for aiming down sights (ADS) in an FPS game. Imagine we have the following ADS system to handle the visuals:  local function aimDownSights() aim:update() local isAiming: number = if aim:pressed() then 1 else 0 local gunOffset = hipOffset:Lerp(aimOffset, isAiming) ... end   After designing a UI button (aimButton) for mobile players, we can use hold() to add the input value to the axis:  local release, touch = nil, nil aimButton.InputBegan:Connect(function(input) if input.UserInputType ~= Enum.UserInputType.MouseButton1 and input.UserInputType ~= Enum.UserInputType.Touch then return end if input.UserInputState ~= Enum.UserInputState.Begin then return end touch = input release = aim:hold() -- this sets the value of the aim input to 1, as if there was a right click end) UserInputService.InputEnded:Connect(function(input) if not releaseJump or input ~= touch or input.UserInputState ~= Enum.UserInputState.End then return end if input.UserInputType ~= Enum.UserInputType.MouseButton1 and input.UserInputType ~= Enum.UserInputType.Touch then return end release() -- this releases the hold, as if the right click was released release = nil end)   This code would make sure that your game can properly support mobile players with intuitive controls, while keeping input handling outside of your game logic (in this case, the aimDownSights() function).  tip You may be wondering why we're using this complicated method instead of aimButton.Activated. Well this strategy is to allow mobile players to continue to drag their camera around while pressing the button (and holding the input axis). This is ideal in a scenario where the gun might shoot automatically when aiming over a player on a mobile device. But this is more common with 'shoot' buttons.  ","version":"Next","tagName":"h3"},{"title":"Move​","type":1,"pageTitle":"Touch","url":"/Axis/docs/Devices/touch#move","content":" If you are using a UI framework like Roact or Vide, or maybe you just have state in a different library, you may want to have a system run every frame that uses move() to connect that state to an input axis.  local isShootButtonPressed -- state that comes from somewhere else local shoot = Axis.input { Enum.KeyCode.ButtonR2, Enum.KeyCode.MouseButton1 } local function handleInput() if isShootButtonPressed() then shoot:move(1) end -- maybe do the same for other input axes end   move() works just like a hold(), except that it is optimized to only add that value to the axis for a single update. This works in this situation since you can only check whether the button is pressed every frame, so it makes sense to just move the axis for that frame and then have it reset automatically the next frame. ","version":"Next","tagName":"h3"},{"title":"Controller","type":0,"sectionRef":"#","url":"/Axis/docs/Devices/controller","content":"Controller If you have taken the time to read through the API, you may have noticed that most methods have a controller parameter with the type of number?. Roblox supports up to 8 &quot;gamepads&quot; and as such, your game may experience up to 8 controllers (and you may want to support this by having different input axes for each controller). local jump = Axis.input { Enum.KeyCode.Space, -- any other inputs will be treated as controller 1 Enum.KeyCode.ButtonA, } In this example, let's say that we let 8 players play locally, each with their own character who may want to jump for whatever reason. You may write a system like this to handle each character: local function jump() for i = 1, 8 do -- if standing on the ground ... if jump:pressed(i) then -- make their character jump end end end Remember that you can use UserInputService:GetConnectedGamepads() to get the number of connected controllers. Almost all methods allow you to specify a controller like this, even move(), hold(), and read().","keywords":"","version":"Next"},{"title":"Best Practices","type":0,"sectionRef":"#","url":"/Axis/docs/Introduction/best_practices","content":"Best Practices You have two main options while using Axis, you can either collect all your input axes in a single module for other systems to require, or you can define them in the systems that need them (may create redundancy). local inputDelta = Axis.input { Enum.UserInputType.MouseMovement, [Enum.KeyCode.Thumbstick1] = 20, } local function camera() ... end OR local inputMap = { inputDelta = Axis.input { Enum.UserInputType.MouseMovement, [Enum.KeyCode.Thumbstick1] = 20, }, attack = Axis.input { Enum.KeyCode.E, Enum.KeyCode.ButtonA, }, block = Axis.input { Enum.KeyCode.F, }, } return inputMap Of course you can do something in between but at killer.gg we have found that containing all the input axes in a single module is the best option, since it allows us to easily access all of them in other systems (see mobileInput.luau and camera.luau in the example game). More stuff soon probably","keywords":"","version":"Next"},{"title":"Getting Started","type":0,"sectionRef":"#","url":"/Axis/docs/Introduction/getting_started","content":"","keywords":"","version":"Next"},{"title":"Installation​","type":1,"pageTitle":"Getting Started","url":"/Axis/docs/Introduction/getting_started#installation","content":" Currently only available on pesde  ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"Getting Started","url":"/Axis/docs/Introduction/getting_started#usage","content":" While this library is agnostic and doesn't require an ECS of any sort, it is definitely ECS-oriented since its meant to be run in systems. Input axes run on a frame by frame basis, meaning they need to be updated every frame.  while wait() do attack:update() -- update the input axes if attack:pressed() then -- fires once, when the input is newly pressed print(&quot;Attacked!&quot;) end end   ","version":"Next","tagName":"h2"},{"title":"Input Axes​","type":1,"pageTitle":"Getting Started","url":"/Axis/docs/Introduction/getting_started#input-axes","content":" To create an input axis, you need to define a keymap. These keymaps can contain keybinds for any devices, as shown here:  local attack = Axis.input { Enum.KeyCode.E, -- for keyboard, though usually redundant with mouse Enum.UserInputType.MouseButton1, -- for mouse Enum.KeyCode.ButtonR2, -- for xbox/ps4 controllers }   In this example, three axes have been defined in the input, E, left click, and the right trigger on console. These axes for example are all positive (by default), meaning that each can either be equal to 0 or 1.  -- if any of the above axes are equal to 1, the input is considered pressing if attack:pressing() then ...   But lets use this idea of axes to use the mouse's scroll wheel as input. The scroll wheel is a special key where the value can either be 0 (for no scroll), 1 (for scrolling up), or -1 (for scrolling down). This means that the axis could be negative or positive.  local zoom = Axis.input { Enum.UserInputType.MouseWheel }   In this case, pressing == when the user is scrolling in either direction. (Pressing is true when the whole input is not equal to 0, this is called being &quot;activated&quot; in the API).  local pressing = zoom:pressing()   So now, using read() is more useful, since it returns the current and previous values of the axis.  local current, previous = zoom:read() -- current will equal either, -1, 0, or 1 -- same for previous!   ","version":"Next","tagName":"h3"},{"title":"Axis Weights​","type":1,"pageTitle":"Getting Started","url":"/Axis/docs/Introduction/getting_started#axis-weights","content":" By default input axes are given a weight of 1. This means that if one axis was positive and another was negative, they would cancel each other out.  local movementIn2D = Axis.input { [Enum.KeyCode.A] = -1, Enum.KeyCode.D, -- by default, given a weight of positive 1 -- [Enum.KeyCode.D] = 1, -- this is explicit, but has same behavior }   If both keys were being pressed at the same time, the value of the input as a whole would be 0, since 1 + (-1) = 0. This is how input is calculated internally- it's just a sum of all the axes. You could weight axes very differently, if you wanted:  local acceleratePedal = Axis.input { [Enum.KeyCode.Q] = 3, [Enum.KeyCode.W] = 1, } local pedal = acceleratePedal:read() -- pedal will equal either 4, 3, 1, or 0   warning Beware of using variable magnitude weights when reading with read() as you may get unexpected results. Remember that the result of read() is a sum of all the axes, so the value have a magnitude of more than 1 or less than -1.  ","version":"Next","tagName":"h3"},{"title":"Vector Axes​","type":1,"pageTitle":"Getting Started","url":"/Axis/docs/Introduction/getting_started#vector-axes","content":" The cool thing about modelling input as axes is that they can be vectors. For example, the common usecase of character movement with WASD:  local move = Axis.input { [Enum.KeyCode.W] = Vector2.new(0, 1), [Enum.KeyCode.S] = Vector2.new(0, -1), [Enum.KeyCode.A] = Vector2.new(-1, 0), [Enum.KeyCode.D] = Vector2.new(1, 0), }   But then you can also add support for the thumbsticks:  ... [Enum.KeyCode.D] = Vector2.new(1, 0), Enum.KeyCode.Thumbstick1, -- could be any Vector2 with a magnitude of 1 }   These vector axes can also have weights, though the weights can only be values that can be multiplied by a vector. For example, you could set mouse sensitivity like this:  local mouse = Axis.input { [Enum.UserInputType.MouseMovement] = 50, -- [Enum.UserInputType.MouseMovement] = Vector2.new(0, 1), -- ^ You can't do this yet (as of v0.1) unfortunately } local delta = mouse:read() -- mouse movement is a variable-magnitude vector, but we still multiply by 50   ","version":"Next","tagName":"h3"},{"title":"More Information​","type":1,"pageTitle":"Getting Started","url":"/Axis/docs/Introduction/getting_started#more-information","content":" To read about more specific features for mobile and console support, check out the device support guides, or check out the API to start using Axis.  Touch: hold() and move() for UI touch controlsController: controller numbers for handling multiple controllersDesktop: mouse stuff ","version":"Next","tagName":"h2"}],"options":{"id":"default"}}